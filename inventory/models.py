# -*- coding: utf-8 -*-
from __future__ import unicode_literals
import datetime

from django.db import models
from django.conf import settings
from invoicing.models import Invoice, InvoiceItem
from accounting.models import Account, Transaction


class Supplier(models.Model):
    name = models.CharField(max_length=64)
    contact_person = models.CharField(max_length=64, blank=True, default="")
    physical_address = models.CharField(max_length=128, blank=True, default="")
    telephone = models.CharField(max_length=16, blank=True, default="")
    email = models.EmailField(max_length=64, blank=True, default="")
    website = models.CharField(max_length=64, blank=True, default="")

    def __str__(self):
        return self.name

class Item(models.Model):
    item_name = models.CharField(max_length = 32)
    code = models.AutoField(primary_key=True)
    unit = models.ForeignKey('inventory.UnitOfMeasure', blank=True, default="")
    unit_sales_price = models.FloatField()
    unit_purchase_price = models.FloatField()
    description = models.TextField(blank=True, default="")
    supplier = models.ForeignKey("inventory.Supplier", blank=True, null=True)
    image = models.FileField(blank=True, null=True, upload_to=settings.MEDIA_ROOT)
    quantity = models.FloatField(blank=True, default=0)
    minimum_order_level = models.IntegerField( default=0)
    maximum_stock_level = models.IntegerField(default=0)
    category = models.ForeignKey('inventory.Category', blank=True, null=True)
    sub_category = models.ForeignKey('inventory.Category', 
       related_name='sub_category', blank=True, null=True)

    def __str__(self):
        return str(self.code) + " - " + self.item_name

    @property
    def stock_value(self):
        return self.unit_sales_price * self.quantity
        
    @property
    def sales_to_date(self):
        items = InvoiceItem.objects.filter(item=self)
        total_sales = reduce(lambda x,y: x + y, [item.quantity * item.price for item in items], 0)
        return total_sales
    
class Order(models.Model):
    expected_receipt_date = models.DateField()
    issue_date = models.DateField()
    supplier = models.ForeignKey('inventory.supplier', blank=True, null=True)
    bill_to = models.CharField(max_length=128, blank=True, default="")
    ship_to = models.CharField(max_length=128, blank=True, default="")
    tracking_number = models.CharField(max_length=64, blank=True, default="")

    notes = models.TextField(blank=True, default="")
    status = models.CharField(max_length=16, choices=[
        ('received', 'Received'),
        ('draft', 'Draft'),
        ('submitted', 'Submitted')
    ])
    
    def __str__(self):
        return 'ORD' + str(self.pk)

    @property
    def total(self):
        return reduce(lambda x, y: x + y , [item.subtotal for item in self.orderitem_set.all()], 0)

    def save(self, *args, **kwargs):
        if True: #check if this is creation or update
            #determine accounts based on order status
            debit = None
            credit = None
            if self.status == 'draft':
                pass
            elif self.status == 'submitted':
                debit = Account.objects.get(name='Current Account')
                credit = Account.objects.get(name='Accounts Receivable')
            else: # received
                debit = Account.objects.get(name='Accounts Receivable')
                credit = Account.objects.get(name='Inventory')
            
            if debit:
                Transaction(
                    date=self.issue_date,
                    amount = self.total,
                    memo = "transaction derived from order number: " + str(self),
                    reference = "transaction derived from order number: " + str(self),
                    credit=credit,
                    debit=debit,
                ).save()
        
        super(Order, self).save(*args, **kwargs)

        if self.status == 'received':
            for item in self.orderitem_set.all():
                item.item.quantity += item.quantity
                
        def receive(self):
            if self.status != 'received':
                StockReceipt(
                    order=self,
                    receive_date= datetime.date.today,
                    note = 'Autogenerated receipt from order number' + \
                        str(self.pk),
                    fully_received=True
                ).save()
                self.status = 'received'

class OrderItem(models.Model):
    order = models.ForeignKey('inventory.Order', null=True)
    item = models.ForeignKey('inventory.item', null=True)
    quantity = models.FloatField()
    #change and move this to the item
    #make changes to the react app as well
    order_price = models.FloatField()
    received = models.BooleanField(default=False)

    def __str__(self):
        return str(self.item) + ' -' + str(self.order_price)

    def save(self, *args, **kwargs):
        super(OrderItem, self).save(*args, **kwargs)
        if not self.order_price:
            self.order_price = self.item.unit_purchase_price

    @property
    def subtotal(self):
        return self.quantity * self.order_price

class UnitOfMeasure(models.Model):
    name = models.CharField(max_length=64)
    descripition = models.TextField(default="")

    def __str__(self):
        return self.name

class Category(models.Model):
    name = models.CharField(max_length=64)
    def __str__(self):
        return self.name

class StockReceipt(models.Model):
    order = models.ForeignKey('inventory.Order', null=True)
    receive_date = models.DateField()
    note =models.TextField(blank=True, default="")
    fully_received = models.BooleanField()

    def __str__(self):
        return str(self.pk) + ' - ' + str(self.receive_date)

    def save(self, *args, **kwargs):
        super(StockReceipt, self).save(*args, **kwargs)
        self.order.status = 'received'
        self.order.save()